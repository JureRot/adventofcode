}
i <- i+1
#second
funcs[[i]] <- c(i-1, funcs[[i-2]][2]+2, funcs[[i-2]][2]+1, funcs[[i-2]][2])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
#between
for (b in 1:(floor(step)-4)) {
funcs[[i]] <- (funcs[[i-1]])+1
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break #break for
}
if (!smaller2) break #break for
i <- i+1
}
if (!smaller2) break #break while
#second to last
funcs[[i]] <- c(i-1, funcs[[i-1]][2], funcs[[i-1]][3])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
#last
funcs[[i]] <- c(i-1, funcs[[i-1]][2])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
step <- step + 0.5
}
}
first_smalles <- tail(values, n=1)
dist
first_smalles
#this code is a shitshow, but it works nad is quite algorithmically correct and stable
input <- 347991
# one right, one up
# two left, two down
# thre right, thee up
# four left, four down
# ...
x <- 0 #horizontal
y <- 0 #vertical
i <- 1
n <- 1
smaller <- TRUE
distance <- 0
while (smaller) {
if (i == input) { #if input 1
smaller <- FALSE
break
}
#right
for (j in 1:n) {
x <- x + 1
i <- i + 1
if (i == input) {
smaller <- FALSE
break #break for loop if come to the end
}
}
if (!smaller) break #break while loop if coem to the end
#up
for (j in 1:n) {
y <- y + 1
i <- i + 1
if (i == input) {
smaller <- FALSE
break
}
}
if (!smaller) break
n <- n + 1 #increase the step
#left
for (j in 1:n) {
x <- x - 1
i <- i + 1
if (i == input) {
smaller <- FALSE
break
}
}
if (!smaller) break
#down
for (j in 1:n) {
y <- y - 1
i <- i + 1
if (i == input) {
smaller <- FALSE
break
}
}
n <- n + 1 #increase the step (for new iteration)
}
dist <- abs(x) + abs(y) #manhattan distance
#part two
funcs <- list(NULL) #list of node:adjacent_nodes
values <- c(1) #calculated values of nodes
i <- 2
step <- 1
smaller2 <- TRUE
while (smaller2) {
if (step == 1) { #for first step (representing: right one, up one)
funcs[[i]] <- c(1)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(2, 1)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
step <- step + 1
} else if (step == 2) { #for second step (representing: left two down two)
funcs[[i]] <- c(3, 2, 1)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(4, 1)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(5, 4, 1)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(6, 1)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
step <- step + 1
} else if (step == 3) { #for third step (representing: right three, up three)
funcs[[i]] <- c(7, 6, 2, 1)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(8, 2, 1)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(9, 2)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(10, 9, 3, 2)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(11, 3, 2)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
funcs[[i]] <- c(12, 3)
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
step <- step + 1
} else if (step < 5) { #for fourth step (representing: left four OR down four)
#first 3 steps are fully hard coded
#here we start the algorithm (expanded in next step)
#first
funcs[[i]] <- c(i-1, funcs[[i-1]][1], funcs[[i-1]][2]+1, funcs[[i-1]][2])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
#second
funcs[[i]] <- c(i-1, funcs[[i-2]][2]+2, funcs[[i-2]][2]+1, funcs[[i-2]][2])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
#third
funcs[[i]] <- c(i-1, funcs[[i-1]][2], funcs[[i-1]][3])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
#fourth
funcs[[i]] <- c(i-1, funcs[[i-1]][2])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
step <- step + 0.5 #we go over twice (same as before, but it was hardcoded, here we can use for loop)
} else {
#expanded algorithm for any step bigger
#first
funcs[[i]] <- c(i-1, funcs[[i-1]][1], funcs[[i-1]][2]+1, funcs[[i-1]][2])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
#second
funcs[[i]] <- c(i-1, funcs[[i-2]][2]+2, funcs[[i-2]][2]+1, funcs[[i-2]][2])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
#between
for (b in 1:(floor(step)-4)) {
funcs[[i]] <- (funcs[[i-1]])+1
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break #break for
}
if (!smaller2) break #break for
i <- i+1
}
if (!smaller2) break #break while
#second to last
funcs[[i]] <- c(i-1, funcs[[i-1]][2], funcs[[i-1]][3])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
#last
funcs[[i]] <- c(i-1, funcs[[i-1]][2])
summa <- 0
for (f in funcs[[i]]) {
summa <- summa + values[f]
}
values <- c(values, summa)
if (summa >= input) {
smaller2 <- FALSE
break
}
i <- i+1
step <- step + 0.5
}
}
first_smalles <- tail(values, n=1)
dist
first_smalles
#this code is a shitshow, but it works and is quite algorithmically correct and stable
input_file = file("input2017_10.txt", "r")
input <- ""
while ( TRUE ) {
line = readLines(input_file, n = 1)
if ( length(line) == 0 ) {
break
}
#print(line)
if (input[1] == "") {
input <- line
} else {
input <- c(input, line)
}
}
close(input_file)
#input <- "1,2,4" #testing input
input <- c(utf8ToInt(input), 17, 31, 73, 47, 23) #change input to ascii code and add standard suffix
indices <- function(start, len, max) { #returns a vector of indides to reverse
if (len == 0) { #if 0 just break
return(integer())
}
end <- (((start-1) + (len-1)) %% max) +1 #calculate what end woul is (accounting for wrapping and index starting with 1) (len-1 is because r includes the last value (1:n))
index <- start:end #prematurely set it (could be incorrect)
if (end < start) { #if end smaller than start (its incorrect), we correct it)
index <- c(start:max, 1:end)
}
return(index)
}
reverse <- function(numbers, index) { #reverses the values of numbers within index
if (length(index) > 1) { #if more than 1 index (if one the reversing chnages nothing)
for (i in 1:floor((length(index) / 2))) { #indexes of just the first half (for other half will look from behind)
temp <- numbers[index[i]]
numbers[index[i]] <- numbers[index[(length(index)-i)+1]] #switch first for last
numbers[index[(length(index)-i)+1]] <- temp #switch last for first
}
}
return(numbers)
}
position <- 1
skip <- 0
numbers <- 0:255 #list of numbers (change to 0:255)
num_len <- length(numbers)
for (bla in 1:64) { #for 64 cycles
for (i in input) { #for every lenght (includin suffix) we do the same as in part 1
numbers <- reverse(numbers, indices(position, i, num_len))
position <- (((position-1) + (i + skip)) %% num_len) +1
skip <- skip + 1
}
}
blocks <- c()
for (i in seq(1, 255, 16)) { #for every block of 16
b <- numbers[i] #create xor value
for (j in (i+1):((i-1)+16)) { #for every number within that block
b <- bitwXor(b, numbers[j]) #bitwise xor it together (to the xor value)
}
blocks <- c(blocks, b) #add it to the blocks
}
hex <- paste(as.hexmode(blocks), collapse = '') #convert decimal to hex string and join it (already has leading zeros)
print(source("AoC2017_10.r")[1]) #print the part 1
hex
setwd("~/Documents/git/other/adventofcode/2017")
input_file = file("input2017_10.txt", "r")
input <- ""
while ( TRUE ) {
line = readLines(input_file, n = 1)
if ( length(line) == 0 ) {
break
}
#print(line)
if (input[1] == "") {
input <- line
} else {
input <- c(input, line)
}
}
close(input_file)
#input <- "1,2,4" #testing input
input <- c(utf8ToInt(input), 17, 31, 73, 47, 23) #change input to ascii code and add standard suffix
indices <- function(start, len, max) { #returns a vector of indides to reverse
if (len == 0) { #if 0 just break
return(integer())
}
end <- (((start-1) + (len-1)) %% max) +1 #calculate what end woul is (accounting for wrapping and index starting with 1) (len-1 is because r includes the last value (1:n))
index <- start:end #prematurely set it (could be incorrect)
if (end < start) { #if end smaller than start (its incorrect), we correct it)
index <- c(start:max, 1:end)
}
return(index)
}
reverse <- function(numbers, index) { #reverses the values of numbers within index
if (length(index) > 1) { #if more than 1 index (if one the reversing chnages nothing)
for (i in 1:floor((length(index) / 2))) { #indexes of just the first half (for other half will look from behind)
temp <- numbers[index[i]]
numbers[index[i]] <- numbers[index[(length(index)-i)+1]] #switch first for last
numbers[index[(length(index)-i)+1]] <- temp #switch last for first
}
}
return(numbers)
}
position <- 1
skip <- 0
numbers <- 0:255 #list of numbers (change to 0:255)
num_len <- length(numbers)
for (bla in 1:64) { #for 64 cycles
for (i in input) { #for every lenght (includin suffix) we do the same as in part 1
numbers <- reverse(numbers, indices(position, i, num_len))
position <- (((position-1) + (i + skip)) %% num_len) +1
skip <- skip + 1
}
}
blocks <- c()
for (i in seq(1, 255, 16)) { #for every block of 16
b <- numbers[i] #create xor value
for (j in (i+1):((i-1)+16)) { #for every number within that block
b <- bitwXor(b, numbers[j]) #bitwise xor it together (to the xor value)
}
blocks <- c(blocks, b) #add it to the blocks
}
hex <- paste(as.hexmode(blocks), collapse = '') #convert decimal to hex string and join it (already has leading zeros)
print(source("AoC2017_10.r")[1]) #print the part 1
hex
