pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
}
if (is.null(new_grid_row)) { #if this the firs, we create
new_grid_row <- pattern
} else { #if allready exists, we bind to right (column bind)
new_grid_row <- cbind(new_grid_row, pattern)
}
}
if (is.null(new_grid)) { #if this the first row, we create
new_grid <- new_grid_row
} else { #if allready exists, we bind to bottom (row bind)
new_grid <- rbind(new_grid, new_grid_row)
}
}
}
grid <- new_grid
print(grid)
}
num_lit <- length(grid[grid == "#"]) #number of cels lit (where gird is #)
num_lit
input_file = file("input2017_21.txt", "r")
input <- ""
while ( TRUE ) {
line = readLines(input_file, n = 1)
if ( length(line) == 0 ) {
break
}
if (input[1] == "") {
input <- line
} else {
input <- c(input, line)
}
}
close(input_file)
input_test <- c("../.# => ##./#../...", ".#./..#/### => #..#/..../..../#..#") #test input
input_test <- gsub("/", "", input)
input_test <- strsplit(input, " => ")
input <- gsub("/", "", input)
input <- strsplit(input, " => ")
# this should be fun
# you can create with vector matrix(data, nrow, ncol, byrow)
# you can get submatrix with m[_,_]
# you can get as vector as.numeric(m[,])
# you can transpose t(m[,])
# you can expand matrix with cbind and rbind
# all rotations and flips:
#   as.character(t(neki))
#   as.character(neki[3:1,])
#   as.character(t(neki[3:1, 3:1]))
#   as.character(neki[,3:1])
#   as.character(t(neki[,3:1]))
#   as.character(neki[3:1, 3:1])
#   as.character(t(neki[3:1,]))
#   as.character(neki)
rules <- list()
for (line in input) { #write all rules
rules[[line[1]]] <- line[2]
}
grid <- matrix(unlist(strsplit(".#...####", "")), nrow=3, ncol=3, byrow=TRUE) #starting grid
for (iter in 1:2) { #for 5 iterations (change to 5)
new_grid <- NULL
if (ncol(grid) %% 2 == 0) { #if size divisible by 2 (ncol or nrow is the same because square matrices)
for (i in 0:((ncol(grid)/2)-1)) {
new_grid_row <- NULL
for (j in 0:((nrow(grid)/2)-1)) {
pattern <- grid[((i*2)+1):((i*2)+2), ((j*2)+1):((j*2)+2)]
if (!is.null(rules[[paste(as.character(t(pattern)), collapse="")]])) { #check for all (rot and flip)
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern)), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[2:1,]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[2:1,]), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[2:1, 2:1])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[2:1, 2:1])), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[,2:1]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[,2:1]), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[,2:1])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[,2:1])), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[2:1, 2:1]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[2:1, 2:1]), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[2:1,])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[2:1,])), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
}
if (is.null(new_grid_row)) { #if this the firs, we create
new_grid_row <- pattern
} else { #if allready exists, we bind to right (column bind)
new_grid_row <- cbind(new_grid_row, pattern)
}
}
if (is.null(new_grid)) { #if this the first row, we create
new_grid <- new_grid_row
} else { #if allready exists, we bind to bottom (row bind)
new_grid <- rbind(new_grid, new_grid_row)
}
}
} else if (nrow(grid) %% 3 == 0) { #if size divisible by 3
for (i in 0:((ncol(grid)/3)-1)) {
new_grid_row <- NULL
for (j in 0:((nrow(grid)/3)-1)) {
pattern <- grid[((i*3)+1):((i*3)+3), ((j*3)+1):((j*3)+3)]
if (!is.null(rules[[paste(as.character(t(pattern)), collapse="")]])) { #check for all (rot and flip)
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern)), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[3:1,]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[3:1,]), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[3:1, 3:1])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[3:1, 3:1])), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[,3:1]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[,3:1]), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[,3:1])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[,3:1])), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[3:1, 3:1]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[3:1, 3:1]), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[3:1,])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[3:1,])), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
}
if (is.null(new_grid_row)) { #if this the firs, we create
new_grid_row <- pattern
} else { #if allready exists, we bind to right (column bind)
new_grid_row <- cbind(new_grid_row, pattern)
}
}
if (is.null(new_grid)) { #if this the first row, we create
new_grid <- new_grid_row
} else { #if allready exists, we bind to bottom (row bind)
new_grid <- rbind(new_grid, new_grid_row)
}
}
}
grid <- new_grid
print(grid)
}
num_lit <- length(grid[grid == "#"]) #number of cels lit (where gird is #)
num_lit
input_file = file("input2017_21.txt", "r")
input <- ""
while ( TRUE ) {
line = readLines(input_file, n = 1)
if ( length(line) == 0 ) {
break
}
if (input[1] == "") {
input <- line
} else {
input <- c(input, line)
}
}
close(input_file)
input <- c("../.# => ##./#../...", ".#./..#/### => #..#/..../..../#..#") #test input
input <- gsub("/", "", input)
input <- strsplit(input, " => ")
# this should be fun
# you can create with vector matrix(data, nrow, ncol, byrow)
# you can get submatrix with m[_,_]
# you can get as vector as.numeric(m[,])
# you can transpose t(m[,])
# you can expand matrix with cbind and rbind
# all rotations and flips:
#   as.character(t(neki))
#   as.character(neki[3:1,])
#   as.character(t(neki[3:1, 3:1]))
#   as.character(neki[,3:1])
#   as.character(t(neki[,3:1]))
#   as.character(neki[3:1, 3:1])
#   as.character(t(neki[3:1,]))
#   as.character(neki)
rules <- list()
for (line in input) { #write all rules
rules[[line[1]]] <- line[2]
}
grid <- matrix(unlist(strsplit(".#...####", "")), nrow=3, ncol=3, byrow=TRUE) #starting grid
for (iter in 1:2) { #for 5 iterations (change to 5)
new_grid <- NULL
if (ncol(grid) %% 2 == 0) { #if size divisible by 2 (ncol or nrow is the same because square matrices)
for (i in 0:((ncol(grid)/2)-1)) {
new_grid_row <- NULL
for (j in 0:((nrow(grid)/2)-1)) {
pattern <- grid[((i*2)+1):((i*2)+2), ((j*2)+1):((j*2)+2)]
if (!is.null(rules[[paste(as.character(t(pattern)), collapse="")]])) { #check for all (rot and flip)
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern)), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[2:1,]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[2:1,]), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[2:1, 2:1])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[2:1, 2:1])), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[,2:1]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[,2:1]), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[,2:1])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[,2:1])), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[2:1, 2:1]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[2:1, 2:1]), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[2:1,])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[2:1,])), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern), collapse="")]], "")), nrow=3, ncol=3, byrow=TRUE)
}
if (is.null(new_grid_row)) { #if this the firs, we create
new_grid_row <- pattern
} else { #if allready exists, we bind to right (column bind)
new_grid_row <- cbind(new_grid_row, pattern)
}
}
if (is.null(new_grid)) { #if this the first row, we create
new_grid <- new_grid_row
} else { #if allready exists, we bind to bottom (row bind)
new_grid <- rbind(new_grid, new_grid_row)
}
}
} else if (nrow(grid) %% 3 == 0) { #if size divisible by 3
for (i in 0:((ncol(grid)/3)-1)) {
new_grid_row <- NULL
for (j in 0:((nrow(grid)/3)-1)) {
pattern <- grid[((i*3)+1):((i*3)+3), ((j*3)+1):((j*3)+3)]
if (!is.null(rules[[paste(as.character(t(pattern)), collapse="")]])) { #check for all (rot and flip)
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern)), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[3:1,]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[3:1,]), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[3:1, 3:1])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[3:1, 3:1])), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[,3:1]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[,3:1]), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[,3:1])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[,3:1])), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern[3:1, 3:1]), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern[3:1, 3:1]), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(t(pattern[3:1,])), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(t(pattern[3:1,])), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
} else if (!is.null(rules[[paste(as.character(pattern), collapse="")]])) {
pattern <- matrix(unlist(strsplit(rules[[paste(as.character(pattern), collapse="")]], "")), nrow=4, ncol=4, byrow=TRUE)
}
if (is.null(new_grid_row)) { #if this the firs, we create
new_grid_row <- pattern
} else { #if allready exists, we bind to right (column bind)
new_grid_row <- cbind(new_grid_row, pattern)
}
}
if (is.null(new_grid)) { #if this the first row, we create
new_grid <- new_grid_row
} else { #if allready exists, we bind to bottom (row bind)
new_grid <- rbind(new_grid, new_grid_row)
}
}
}
grid <- new_grid
print(grid)
}
num_lit <- length(grid[grid == "#"]) #number of cels lit (where gird is #)
num_lit
setwd("~/Documents/git/other/adventofcode/2017")
input_file = file("input2017_23.txt", "r")
input <- ""
while ( TRUE ) {
line = readLines(input_file, n = 1)
if ( length(line) == 0 ) {
break
}
if (input[1] == "") {
input <- line
} else {
input <- c(input, line)
}
}
close(input_file)
input <- strsplit(input, " ")
get_value <- function(registers, x) {#gets value of x, number or register
value <- 0
if (suppressWarnings(!is.na(as.numeric(x)))) { #input is number
value <- as.numeric(x) #we just use the number
} else { #is register name
value <- registers[[x]]
}
return(value)
}
set <- function(registers, x, y) { #sets reg x with value y
registers[[x]] <- get_value(registers, y)
return(registers)
}
sub <- function(registers, x, y) { #decrease the value of reg x by value of y
registers[[x]] <- registers[[x]] + get_value(registers, y)
return(registers)
}
mul <- function(registers, x, y) { #multiplies the value of reg x by value of y
state$registers[[x]] <- state$registers[[x]] * get_value(registers, y)
return(registers)
}
jnz <- function(registers, x, y) { #if value of x not zero, we jump with offset y (plus or minus)
offset <- 1 #default offset is one (just go to next command)
if (get_value(registers, x) != 0) { #if value of x greater than zero we change value of offset
offset <- get_value(registers, y)
}
return(offset)
}
registers <- new.env()
for (r in c("a", "b", "c", "d", "e", "f", "g", "h")) { #we init all registers with zeros
registers[[r]] <- 0
}
num_mul <- 0
i <- 1
while((i >= 1) & (i <= length(input))) {
if (input[[i]][1] == "set") {
registers <- set(registers, input[[i]][2], input[[i]][3])
i <- i + 1
} else if (input[[i]][1] == "sub") {
registers <- sub(registers, input[[i]][2], input[[i]][3])
i <- i + 1
} else if (input[[i]][1] == "mul") {
registers <- mul(registers, input[[i]][2], input[[i]][3])
i <- i + 1
num_mul <- num_mul + 1
} else if (input[[i]][1] == "jnz") {
i <- i + jnz(registers, input[[i]][2], input[[i]][3])
}
print(c(registers$a, registers$b, registers$c, registers$d, registers$e, registers$f, registers$g, registers$h))
}
num_mul
input_file = file("input2017_23.txt", "r")
input <- ""
while ( TRUE ) {
line = readLines(input_file, n = 1)
if ( length(line) == 0 ) {
break
}
if (input[1] == "") {
input <- line
} else {
input <- c(input, line)
}
}
close(input_file)
input <- strsplit(input, " ")
get_value <- function(registers, x) {#gets value of x, number or register
value <- 0
if (suppressWarnings(!is.na(as.numeric(x)))) { #input is number
value <- as.numeric(x) #we just use the number
} else { #is register name
value <- registers[[x]]
}
return(value)
}
set <- function(registers, x, y) { #sets reg x with value y
registers[[x]] <- get_value(registers, y)
return(registers)
}
sub <- function(registers, x, y) { #decrease the value of reg x by value of y
registers[[x]] <- registers[[x]] + get_value(registers, y)
return(registers)
}
mul <- function(registers, x, y) { #multiplies the value of reg x by value of y
state$registers[[x]] <- registers[[x]] * get_value(registers, y)
return(registers)
}
jnz <- function(registers, x, y) { #if value of x not zero, we jump with offset y (plus or minus)
offset <- 1 #default offset is one (just go to next command)
if (get_value(registers, x) != 0) { #if value of x greater than zero we change value of offset
offset <- get_value(registers, y)
}
return(offset)
}
registers <- new.env()
for (r in c("a", "b", "c", "d", "e", "f", "g", "h")) { #we init all registers with zeros
registers[[r]] <- 0
}
num_mul <- 0
i <- 1
while((i >= 1) & (i <= length(input))) {
if (input[[i]][1] == "set") {
registers <- set(registers, input[[i]][2], input[[i]][3])
i <- i + 1
} else if (input[[i]][1] == "sub") {
registers <- sub(registers, input[[i]][2], input[[i]][3])
i <- i + 1
} else if (input[[i]][1] == "mul") {
registers <- mul(registers, input[[i]][2], input[[i]][3])
i <- i + 1
num_mul <- num_mul + 1
} else if (input[[i]][1] == "jnz") {
i <- i + jnz(registers, input[[i]][2], input[[i]][3])
}
print(c(registers$a, registers$b, registers$c, registers$d, registers$e, registers$f, registers$g, registers$h))
}
num_mul
input_file = file("input2017_23.txt", "r")
input <- ""
while ( TRUE ) {
line = readLines(input_file, n = 1)
if ( length(line) == 0 ) {
break
}
if (input[1] == "") {
input <- line
} else {
input <- c(input, line)
}
}
close(input_file)
input <- strsplit(input, " ")
get_value <- function(registers, x) {#gets value of x, number or register
value <- 0
if (suppressWarnings(!is.na(as.numeric(x)))) { #input is number
value <- as.numeric(x) #we just use the number
} else { #is register name
value <- registers[[x]]
}
return(value)
}
set <- function(registers, x, y) { #sets reg x with value y
registers[[x]] <- get_value(registers, y)
return(registers)
}
sub <- function(registers, x, y) { #decrease the value of reg x by value of y
registers[[x]] <- registers[[x]] + get_value(registers, y)
return(registers)
}
mul <- function(registers, x, y) { #multiplies the value of reg x by value of y
registers[[x]] <- registers[[x]] * get_value(registers, y)
return(registers)
}
jnz <- function(registers, x, y) { #if value of x not zero, we jump with offset y (plus or minus)
offset <- 1 #default offset is one (just go to next command)
if (get_value(registers, x) != 0) { #if value of x greater than zero we change value of offset
offset <- get_value(registers, y)
}
return(offset)
}
registers <- new.env()
for (r in c("a", "b", "c", "d", "e", "f", "g", "h")) { #we init all registers with zeros
registers[[r]] <- 0
}
num_mul <- 0
i <- 1
while((i >= 1) & (i <= length(input))) {
if (input[[i]][1] == "set") {
registers <- set(registers, input[[i]][2], input[[i]][3])
i <- i + 1
} else if (input[[i]][1] == "sub") {
registers <- sub(registers, input[[i]][2], input[[i]][3])
i <- i + 1
} else if (input[[i]][1] == "mul") {
registers <- mul(registers, input[[i]][2], input[[i]][3])
i <- i + 1
num_mul <- num_mul + 1
} else if (input[[i]][1] == "jnz") {
i <- i + jnz(registers, input[[i]][2], input[[i]][3])
}
print(c(registers$a, registers$b, registers$c, registers$d, registers$e, registers$f, registers$g, registers$h))
}
input_file = file("input2017_23.txt", "r")
input <- ""
while ( TRUE ) {
line = readLines(input_file, n = 1)
if ( length(line) == 0 ) {
break
}
if (input[1] == "") {
input <- line
} else {
input <- c(input, line)
}
}
close(input_file)
input <- strsplit(input, " ")
get_value <- function(registers, x) {#gets value of x, number or register
value <- 0
if (suppressWarnings(!is.na(as.numeric(x)))) { #input is number
value <- as.numeric(x) #we just use the number
} else { #is register name
value <- registers[[x]]
}
return(value)
}
set <- function(registers, x, y) { #sets reg x with value y
registers[[x]] <- get_value(registers, y)
return(registers)
}
sub <- function(registers, x, y) { #decrease the value of reg x by value of y
registers[[x]] <- registers[[x]] + get_value(registers, y)
return(registers)
}
mul <- function(registers, x, y) { #multiplies the value of reg x by value of y
registers[[x]] <- registers[[x]] * get_value(registers, y)
return(registers)
}
jnz <- function(registers, x, y) { #if value of x not zero, we jump with offset y (plus or minus)
offset <- 1 #default offset is one (just go to next command)
if (get_value(registers, x) != 0) { #if value of x greater than zero we change value of offset
offset <- get_value(registers, y)
}
return(offset)
}
registers <- new.env()
for (r in c("a", "b", "c", "d", "e", "f", "g", "h")) { #we init all registers with zeros
registers[[r]] <- 0
}
num_mul <- 0
i <- 1
while((i >= 1) & (i <= length(input))) {
if (input[[i]][1] == "set") {
registers <- set(registers, input[[i]][2], input[[i]][3])
i <- i + 1
} else if (input[[i]][1] == "sub") {
registers <- sub(registers, input[[i]][2], input[[i]][3])
i <- i + 1
} else if (input[[i]][1] == "mul") {
registers <- mul(registers, input[[i]][2], input[[i]][3])
i <- i + 1
num_mul <- num_mul + 1
} else if (input[[i]][1] == "jnz") {
i <- i + jnz(registers, input[[i]][2], input[[i]][3])
}
#print(c(registers$a, registers$b, registers$c, registers$d, registers$e, registers$f, registers$g, registers$h))
print(num_mul)
}
